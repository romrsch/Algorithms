#include <iostream>
#include <array>

using namespace std;

int main(){

    setlocale(LC_ALL, "Russian");

// Select sort,  O(n^2)
/*
Изначально массив считается НЕ сортированным
находим НАИМЕНЬШИЙ элемент в несортирванной части массива и меняем его с первым элементом (со значением в текущем индексе)

Алгоритм рассматриваем левый элемнт массива, считая его минимальным и сравнивать это элемент с оставшей частью несортированного массива.

1. массив делится на два подмассива (левая (отсортированная) и правая часть (не сортированная))
2. всегда выбираем крайний левый элемент в несортированном массиве (считаем его минимальным по-умолчанию min_pos)
3. сравниваем min_pos с остальными элементами массива -  если срели них находим меньше, чем min_pos то выполняем замену
4. происходит сдвиг, отсортированный элемент не рассматривается и рассматриваем следующий элемент.

будет два цикла
внешний цикл i от 0 до length-1
внутренний цикл j от i+1 до length

*/


int a[] = {3, 2, 5, 1, 4};
//int n = 5;
int length = sizeof(a)/sizeof(a[0]); // размер массива, так красиво.

int i, j, min_pos, temp; // счетчики для циклов, наименьший элемент, временная переменная для swap значений

// выводим на печать массив
cout << " " << endl;
cout << "Исходный массив: "<< endl;
cout << "----------------------"<< endl;

    for( i = 0 ; i < length; i++)
        {
            cout << a[i] << " ";
        }

// Алгоритм сортировки:

for( i = 0; i < (length-1); i++) // внешний цикл проходит от 0 до n-1 (сравниваем последний и предпоследний элементы) - оставшийся последний элемент будет максимальным (будет на своем месте)
    {
        min_pos = i; // считаем, что самый левый элемент в неотсортированной части массива i - это самый маленький элемент.

        for(j = i+1; j < length; j++ ) // внутренний цикл - проходим все элементы до n, начиаем сравнивать min_pos и соседний с ним элемент.
            {
                if(a[j] < a[min_pos])  // делаем сравнение
                    {
                        min_pos = j;
                    }

            }

        if (min_pos != i){ // необязательно, т.е. проверяем если минимальный элемент не одно и тоже, то выполняем замену, чтобы лишний раз не делать замену.
        temp = a[i];    // swap происходит здесь - во внешнем цикле, используя временную переменную меняем местами элементы
        a[i] = a[min_pos];
        a[min_pos] = temp;
            }
        }

// выводим на печать массив
cout << " " << endl;
cout << "Отсортированный массив: "<< endl;
cout << "----------------------"<< endl;

for( i = 0 ; i < length; i++)
    {
        cout << a[i] << " ";
    }

return 0;

}
